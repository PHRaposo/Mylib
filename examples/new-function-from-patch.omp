; OM File Header - Saved 2021/01/16 9:46:01
; (6.17 :patc (om-make-point 6 106) (om-make-point 50 50) (om-make-point 1055 553) "" 183 0 "2021/01/16 9:36:34" "2021/01/16 9:46:01")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "new-function-from-patch" (quote ((let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 327 209) (om-make-point 81 30) (list 0 1 2 3 4 5) "(0 1 2 3 4 5)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "all-rotations" (om-load-lisp-abspatch "all-rotations" 6.17 "(lambda (num-list)$(mapcar #'(lambda (input1)$(rotate num-list input1))$(arithm-ser 0 (1- (length num-list)) 1)))") (quote ((om-load-inputfun (quote input-funbox) "" "NUM-LIST" nil))) (om-make-point 327 281) nil (list (list (list 0 1 2 3 4 5) (list 1 2 3 4 5 0) (list 2 3 4 5 0 1) (list 3 4 5 0 1 2) (list 4 5 0 1 2 3) (list 5 0 1 2 3 4))) nil "all-rotations"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXT-VIEW" (quote text-view) (quote ((om-load-inputfun (quote input-funbox) "dialog-item text (string)" "text" "untitled"))) (om-make-point 246 44) (om-make-point 611 154) (let ((rep (om-make-dialog-item (quote text-view) (om-make-point 1 1) (om-make-point 587 134) "untitled"))) (om-set-dialog-item-text rep "(lambda (num-list)
(mapcar #'(lambda (input1)
; main-function - rotate has two arguments - the initial num-list (fixed) and an nth list for rotations (loop)
(rotate num-list input1))
; now the list for loop
(arithm-ser 0 (1- (length num-list)) 1)))") rep) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 108 296) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 208 187) (om-make-point 27 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 139 183) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 148 219) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "1-" (quote 1-) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 178 144) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 171 88) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 50 42) (om-make-point 81 30) (list 0 1 2 3 4 5) "(0 1 2 3 4 5)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ROTATE" (quote rotate) (quote ((om-load-inputfun (quote input-funbox) "the list" "LIST" nil) (om-load-inputfun (quote input-funbox) "nth" "NTH" 1))) (om-make-point 75 120) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (10 0 3 0 nil 0) (6 0 3 1 nil 0) (5 0 6 0 nil 0) (7 0 6 1 nil 0) (4 0 6 2 nil 0) (8 0 7 0 nil 0) (9 0 8 0 nil 0) (9 0 10 0 nil 0))) nil 6.17))